<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Server Monitoring Dashboard - Vue.js</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <style>
    #app {
      transition: opacity 0.5s;
    }

    .server-card {
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      background-color: #ffffff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .server-card .card-header {
      background-color: #007bff;
      color: white;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      font-size: 1.25rem;
    }

    .server-card.status-error .card-header {
      background-color: #dc3545;
    }

    .server-card .card-body {
      padding: 15px;
      flex-grow: 1;
      background-color: #ffffffee;
      color: black;
    }

    .status-badge {
      font-size: 1.1em;
      padding: 5px 10px;
      border-radius: 5px;
    }

    .status-ok {
      background-color: #28a745;
      color: white;
    }

    .status-error {
      background-color: #dc3545;
      color: white;
    }

    .status-warning {
      background-color: #ffc107;
      color: #343a40;
    }

    .status-loading {
      background-color: #6c757d;
      color: white;
    }

    .metric-item {
      margin-bottom: 8px;
    }

    .metric-item strong {
      display: inline-block;
      width: 80px;
      font-weight: 600;
    }

    .progress {
      height: 15px;
      font-size: 0.75rem;
      margin-top: 5px;
    }

    .timestamp {
      font-size: 0.8em;
      color: #6c757d;
      border-top: 1px solid #eee;
      padding-top: 10px;
      margin-top: 15px;
    }

    .metric-column {
      border-left: 1px solid #eee;
      padding-left: 15px;
    }

    .metric-column:first-child {
      border-left: none;
    }

    .metric-column h4 {
      font-size: 1rem;
      margin-bottom: 10px;
      color: #495057;
    }

    .log-pre {
      background-color: #e9ecef;
      padding: 8px;
      border-radius: 5px;
      overflow: auto;
      font-size: 0.8em;
      max-height: 150px;
      min-height: 50px;
    }

    .loading-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 200px;
      color: #6c757d;
    }
  </style>
</head>


<body>

  <div id="app" :class="{ 'loaded': initialLoadComplete }" class="container-fluid my-4">
    <div class="d-flex align-items-center mb-4">
      <button v-if="selectedServer" @click="selectServer(null)" class="btn btn-outline-secondary me-3">
        <i class="fa-solid fa-arrow-left"></i> Back
      </button>
      <h1 class="text-center flex-grow-1 m-0">
        {{ selectedServer ? selectedServer.name : 'Server Monitoring Dashboard' }}
      </h1>
      <button @click="toggleTheme" class="btn btn-outline-secondary ms-3">
        <i class="fa-solid" :class="theme === 'light' ? 'fa-moon' : 'fa-sun'"></i>
      </button>
    </div>

    <div v-if="!selectedServer" class="row">
      <div v-for="server in servers" :key="server.name" class="col-sm-6 col-md-3 my-2">
        <div class="card server-card" :class="{ 'status-error': server.data && server.data.status === 'ERROR' }">
          <div class="card-header">
            <span>{{ server.name }}</span>
            <span class="status-badge" :class="getStatusClass(server)">
              {{ getStatusText(server) }}
            </span>
          </div>
          <div class="card-body d-flex flex-column">
            <div v-if="server.isLoading" class="loading-placeholder">
              <div class="spinner-border spinner-border-sm" role="status"></div>
            </div>
            <div v-else class="flex-grow-1">
              <div class="metric-item"><strong>Load Avg:</strong> <span>{{ getLoadAvg(server.data) }}</span></div>
              <div class="metric-item"><strong>Memory:</strong>
                <div class="progress" role="progressbar" data-bs-toggle="tooltip"
                  :data-bs-title="`Used: ${getMemoryInfo(server.data).physical.used}`">
                  <div class="progress-bar" :class="getProgressBarClass(getMemoryInfo(server.data).physical.percent)"
                    :style="{ width: getMemoryInfo(server.data).physical.percent + '%' }">
                    {{ getMemoryInfo(server.data).physical.percent }}%
                  </div>
                </div>
                <div class="progress" role="progressbar" data-bs-toggle="tooltip"
                  :data-bs-title="`Used: ${getMemoryInfo(server.data).virtual.used}`">
                  <div class="progress-bar" :class="getProgressBarClass(getMemoryInfo(server.data).virtual.percent)"
                    :style="{ width: getMemoryInfo(server.data).virtual.percent + '%' }">
                    {{ getMemoryInfo(server.data).virtual.percent }}%
                  </div>
                </div>
              </div>
              <div class="metric-item"><strong>Disk:</strong>
                <div v-for="disk in getStorageList(server.data)" :key="disk.mountPoint">
                  <div v-if="!disk.mountPoint.startsWith('/boot')" class="progress mt-1" role="progressbar"
                    data-bs-toggle="tooltip" :data-bs-title="`${disk.mountPoint}: ${disk.used} of ${disk.total}`">
                    <div class="progress-bar" :class="getProgressBarClass(disk.percent)"
                      :style="{ width: disk.percent + '%' }">
                      {{ disk.percent }}%
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <button class="btn btn-sm btn-outline-primary w-100 mt-auto" @click="selectServer(server)">
              View Full Info
            </button>
          </div>
        </div>
      </div>
    </div>

    <div v-else>
      <div class="card server-card">
        <div class="card-body">
          <div v-if="selectedServer.data" class="row">
            <div class="col-lg-4 metric-column">
              <h4>System Logs & Status</h4>
              <div class="metric-item"><strong>Load Avg:</strong> <span>{{ getLoadAvg(selectedServer.data) }}</span>
              </div>
              <div class="metric-item">
                <strong>RAM</strong>
                <div class="progress" role="progressbar" data-bs-toggle="tooltip"
                  :data-bs-title="`Used: ${getMemoryInfo(selectedServer.data).physical.used}, Total: ${getMemoryInfo(selectedServer.data).physical.total}`">
                  <div class="progress-bar"
                    :class="getProgressBarClass(getMemoryInfo(selectedServer.data).physical.percent)"
                    :style="{ width: getMemoryInfo(selectedServer.data).physical.percent + '%' }">
                    {{ getMemoryInfo(selectedServer.data).physical.percent }}%
                  </div>
                </div>
                <strong class="mt-2">Swap</strong>
                <div class="progress mt-1" role="progressbar" data-bs-toggle="tooltip"
                  :data-bs-title="`Used: ${getMemoryInfo(selectedServer.data).virtual.used}, Total: ${getMemoryInfo(selectedServer.data).virtual.total}`">
                  <div class="progress-bar"
                    :class="getProgressBarClass(getMemoryInfo(selectedServer.data).virtual.percent)"
                    :style="{ width: getMemoryInfo(selectedServer.data).virtual.percent + '%' }">
                    {{ getMemoryInfo(selectedServer.data).virtual.percent }}%
                  </div>
                </div>
              </div>
              <strong>Storage</strong>
              <div v-for="disk in getStorageList(selectedServer.data)" :key="disk.mountPoint"
                class="metric-item d-flex align-items-center mt-1">
                <span class="me-2" style="min-width: 50px;">{{ disk.mountPoint }}</span>
                <div class="progress flex-grow-1" role="progressbar" data-bs-toggle="tooltip"
                  :data-bs-title="`Used: ${disk.used}, Total: ${disk.total}`">
                  <div class="progress-bar" :class="getProgressBarClass(disk.percent)"
                    :style="{ width: disk.percent + '%' }">
                    {{ disk.percent }}%
                  </div>
                </div>
              </div>
              <div class="mt-3">
                <h4>CPU</h4>
                <pre class="log-pre">{{ formatLog(selectedServer.data.logs.cpuinfo) }}</pre>
                <h4>Mem</h4>
                <pre class="log-pre mt-2">{{ formatLog(selectedServer.data.logs.meminfo) }}</pre>
                <h4>Disk</h4>
                <pre class="log-pre mt-2">{{ formatLog(selectedServer.data.logs.storage) }}</pre>
                <h4>Quota</h4>
                <pre class="log-pre">{{ formatLog(selectedServer.data.logs.quota) }}</pre>
                <h4>Nginx</h4>
                <pre class="log-pre">{{ formatLog(selectedServer.data.logs.nginx) }}</pre>
                <h4>Named</h4>
                <pre class="log-pre mt-2">{{ formatLog(selectedServer.data.logs.named) || 'OK' }}</pre>
                <strong class="mt-2 d-block">FPM Status</strong>
                <div v-if="selectedServer.data.logs.fpms && Object.keys(selectedServer.data.logs.fpms).length > 0">
                  <div v-for="(status, service) in selectedServer.data.logs.fpms" :key="service"
                    class="d-flex justify-content-between align-items-center mb-2">
                    <span class="me-2 text-truncate" data-bs-toggle="tooltip" :data-bs-title="service">
                      {{ service }}
                    </span>
                    <span class="badge" :class="getFpmStatusClass(status)">{{ status }}</span>
                  </div>
                </div>
              </div>
            </div>

            <div class="col-lg-8 metric-column">
              <h4>Performance Stats</h4>
              <div v-if="selectedServer.statsLoading" class="loading-placeholder" style="min-height: 30rem;">
                <div class="spinner-border" role="status"></div>
                <span class="mt-2">Loading performance data...</span>
              </div>
              <div v-else-if="selectedServer.statsError" class="alert alert-warning">
                Could not load performance stats: {{ selectedServer.statsError }}
              </div>
              <div v-else-if="selectedServer.stats" class="row">
                <div v-for="key in statKeys" :key="key" class="col-xl-6">
                  <h5>{{ key.charAt(0).toUpperCase() + key.slice(1) }}</h5>
                  <div class="chart-container">
                    <canvas :id="`${key}-chart`"></canvas>
                  </div>
                </div>
              </div>

              <h5 class="my-2">User Ports</h5>
              <div v-if="selectedServer.portsLoading">
                ...
              </div>
              <div v-else-if="selectedServer.portsError" class="alert alert-warning">
                Could not load user ports data: {{ selectedServer.portsError }}
              </div>
              <div v-else-if="selectedServer.ports" class="d-flex flex-wrap font-monospace">
                <div v-for="port in selectedServer.ports" :key="port[0]" data-bs-toggle="tooltip"
                  :data-bs-title="port[0]" class="mx-1" :class="getPortStatusClass(port)">
                  {{port[1]}} {{port[2] ? '🟢' : '🔴'}}
                </div>
              </div>
            </div>

            <div class="col-12 timestamp mt-3 text-end">Last log update: {{
              formatTimestamp(selectedServer.data.timestamp) }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, onMounted, watch, nextTick } = Vue;

    createApp({
      setup() {
        const servers = ref([
          "sgx.domcloud.co",
          "wdc.domcloud.co",
          "nue.domcloud.co",
          "sgp.domcloud.co",
          "mnz.domcloud.co",
          "osk.domcloud.co",
          "sao.domcloud.co",
        ].map(name => ({
          name,
          data: null,
          stats: null,
          statsLoading: false,
          statsError: null,
          ports: null,
          portsLoading: false,
          portsError: null,
          error: null,
          isLoading: true
        })));
        const initialLoadComplete = ref(false);
        const selectedServer = ref(null);
        let chartInstances = {};

        // --- Data Fetching ---
        const fetchServerStatus = async (server) => {
          server.isLoading = true;
          server.error = null;
          try {
            const response = await fetch(`https://${server.name}/status/test`);
            if (!response.ok) {
              server.error = true;
            }
            server.data = await response.json();
          } catch (err) {
            server.error = err.message;
            server.data = null;
          } finally {
            server.isLoading = false;
          }
        };

        const fetchServerStats = async (server) => {
          if (!server) return;
          server.statsLoading = true;
          server.statsError = null;
          try {
            const response = await fetch(`https://${server.name}/status/stats`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            server.stats = await response.json();
            delete server.stats.temp;
          } catch (err) {
            server.statsError = err.message;
            server.stats = null;
          } finally {
            server.statsLoading = false;
          }
        };

        const fetchServerPorts = async (server) => {
          if (!server) return;
          server.portsLoading = true;
          server.portsError = null;
          try {
            const response = await fetch(`https://${server.name}/status/ports`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            server.ports = [...await response.json()].sort((a, b) => parseInt(a[1]) - parseInt(b[1]));
          } catch (err) {
            server.portsError = err.message;
            server.ports = null;
          } finally {
            server.portsLoading = false;
          }
        };

        const initializeDashboard = () => {
          const fetchPromises = servers.value.map(s => fetchServerStatus(s));
          Promise.allSettled(fetchPromises).then(() => initialLoadComplete.value = true);
        };

        // 1. STATE: Create reactive state for the theme
        const theme = ref('light');

        // 2. TOGGLE FUNCTION: Create a function to switch the theme
        const toggleTheme = () => {
          theme.value = theme.value === 'light' ? 'dark' : 'light';
        };

        // 3. WATCHER: Watch for theme changes and apply them
        watch(theme, (newTheme) => {
          // Set the data-bs-theme attribute on the <html> element
          document.documentElement.setAttribute('data-bs-theme', newTheme);
          // Save the user's preference to localStorage
          localStorage.setItem('theme', newTheme);
        }, { immediate: true }); // 'immediate' runs the watcher right away on load

        onMounted(() => {
          const savedTheme = localStorage.getItem('theme');
          const userPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

          if (savedTheme) {
            theme.value = savedTheme;
          } else if (userPrefersDark) {
            theme.value = 'dark';
          }

          // This line is from your existing code, keep it.
          initializeDashboard();
        });

        // --- Chart Management ---
        const destroyCharts = () => {
          Object.values(chartInstances).forEach(chart => chart.destroy());
          chartInstances = {};
        };

        const renderCharts = (statsData) => {
          destroyCharts();
          if (!statsData) return;

          const colors = {
            read: '#0d6efd',
            write: '#198754',
            sent: '#0d6efd',
            received: '#198754',
          };

          const chartKeys = Object.keys(statsData);
          chartKeys.forEach(key => {
            const canvas = document.getElementById(`${key}-chart`);
            if (!canvas) return;

            let datasets;
            const metricData = statsData[key];

            // NEW: Special handling for 'disk' and 'net' with the y: [val1, val2] structure
            if ((key === 'disk' || key === 'net') && Array.isArray(metricData)) {
              const labels = (key === 'disk') ? ['read', 'write'] : ['sent', 'received'];
              const lineColors = (key === 'disk') ? [colors.read, colors.write] : [colors.sent, colors.received];

              datasets = labels.map((label, index) => {
                return {
                  label: label.toUpperCase(),
                  // Transform the data: create a new point using the y value from the correct index
                  data: metricData.map(point => ({
                    x: point.x * 1000,
                    y: Math.trunc(point.y[index] / 1024),
                  })),
                  borderColor: lineColors[index],
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.1,
                  fill: false,
                };
              });

            } else if (metricData && typeof metricData === 'object' && !Array.isArray(metricData)) {
              // Previous logic for other types of nested objects (fallback)
              datasets = Object.keys(metricData).map(subKey => ({
                label: subKey.toUpperCase(),
                data: metricData[subKey].map(point => ({ ...point, x: point.x * 1000 })),
                borderColor: colors[subKey] || '#6c757d',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.1,
                fill: false,
              }));
            } else {
              // Previous logic for simple arrays (e.g., cpu, mem)
              datasets = [{
                label: key.toUpperCase(),
                data: metricData.map(point => ({ ...point, x: point.x * 1000 })),
                borderColor: '#007bff',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.1,
                fill: false,
              }];
            }

            const getYAxisUnit = (chartKey) => {
              const lowerKey = chartKey.toLowerCase();
              if (lowerKey === 'cpu' || lowerKey === 'mem' || lowerKey === 'virt') return '%';
              if (lowerKey === 'disk' || lowerKey === 'net') return 'KB/s';
              return '';
            };

            const chartOptions = {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              parsing: { xAxisKey: 'x', yAxisKey: 'y' },
              scales: {
                x: {
                  type: 'time',
                  time: { unit: 'hour', tooltipFormat: 'PP pp', displayFormats: { hour: 'ha' } },
                  ticks: { maxRotation: 0, major: { enabled: true } },
                },
                y: {
                  beginAtZero: true,
                  ticks: {
                    callback: (value) => value + ' ' + getYAxisUnit(key)
                  }
                }
              },
              plugins: {
                legend: { display: datasets.length > 1 }
              }
            };

            chartInstances[key] = new Chart(canvas, { type: 'line', data: { datasets }, options: chartOptions });
          });
        };
        // Watch for server selection changes to fetch stats and render/destroy charts
        watch(selectedServer, (newServer, oldServer) => {
          destroyCharts();
          if (newServer) {
            Promise.all([
              newServer.stats || fetchServerStats(newServer),
              newServer.ports || fetchServerPorts(newServer),
            ].filter(x => x)).then(() => {
              nextTick(() => {
                initializeTooltips();
              });
            })
          }
        });

        // Watch for the stats data itself to render charts
        watch(() => selectedServer.value?.stats, (newStats) => {
          if (newStats) {
            nextTick(() => { // Wait for the DOM to be updated with the canvases
              renderCharts(newStats);
            });
          }
        }, { deep: true });

        // --- UI Methods & Helpers ---
        const selectServer = (server) => {
          selectedServer.value = server;
        };

        const getStatusText = (server) => {
          if (server.isLoading) return 'LOADING';
          if (server.error) return 'ERROR';
          return server.data?.status || 'UNKNOWN';
        };

        const getStatusClass = (server) => {
          const status = getStatusText(server);
          return {
            'status-ok': status === 'OK',
            'status-error': Boolean(server.error),
            'status-warning': !['OK', 'ERROR', 'LOADING'].includes(status),
            'status-loading': status === 'LOADING'
          };
        };

        const getLoadAvg = (data) => {
          const line = data?.logs?.cpuinfo?.[0] || '';
          const match = line.match(/load average: ([\d. ,]+)/);
          return match ? match[1] : 'N/A';
        };

        const getMemoryInfo = (data) => {
          const memLine = data?.logs?.meminfo?.[1] || '';
          const swapLine = data?.logs?.meminfo?.[2] || '';

          // Default empty state
          const result = {
            physical: { percent: 0, used: 'N/A', total: 'N/A' },
            virtual: { percent: 0, used: 'N/A', total: 'N/A' }
          };

          // Parse Physical Memory (RAM)
          const memVals = memLine.split(/\s+/).filter(Boolean);
          if (memVals.length >= 3) {
            const totalMem = parseHumanReadableSize(memVals[1]);
            const usedMem = parseHumanReadableSize(memVals[2]);
            if (totalMem > 0) {
              result.physical = {
                percent: ((usedMem / totalMem) * 100).toFixed(0),
                used: `${usedMem} KiB`,
                total: `${totalMem} KiB`
              };
            }
          }

          // Parse Virtual Memory (Swap)
          const swapVals = swapLine.split(/\s+/).filter(Boolean);
          if (swapVals.length >= 3) {
            const totalSwap = parseHumanReadableSize(swapVals[1]);
            const usedSwap = parseHumanReadableSize(swapVals[2]);
            if (totalSwap > 0) {
              result.virtual = {
                percent: ((usedSwap / totalSwap) * 100).toFixed(0),
                used: `${usedSwap} KiB`,
                total: `${totalSwap} KiB`
              };
            }
          }

          return result;
        };

        const getStorageList = (data) => {
          const storageLogs = data?.logs?.storage;
          if (!Array.isArray(storageLogs)) return [];
          return storageLogs.map(line => {
            const parts = line.split(/\s+/).filter(Boolean);
            if (parts.length < 6) return null;
            return { mountPoint: parts[5], percent: parseFloat(parts[4]) || 0, used: parts[2], total: parts[1] };
          }).filter(Boolean);
        };

        const getProgressBarClass = (percent) => {
          if (percent > 80) return 'bg-danger';
          if (percent > 60) return 'bg-warning';
          return 'bg-success';
        };

        const formatLog = (logData) => {
          if (!logData) return 'N/A';
          if (Array.isArray(logData)) return logData.join('\n');
          return logData.toString();
        };

        const getFpmStatusClass = (status) => {
          return status.length == 0 ? 'bg-success' : 'bg-danger';
        };

        const getPortStatusClass = (port) => {
          return port[2] ? 'text-success' : 'text-danger';
        };

        const parseHumanReadableSize = (sizeStr) => {
          if (!sizeStr || typeof sizeStr !== 'string') return 0;

          const size = parseFloat(sizeStr);
          const unit = sizeStr.toLowerCase();

          if (unit.includes('gi')) {
            return size * 1024; // Convert GiB to MiB
          }
          if (unit.includes('mi')) {
            return size; // Already in MiB
          }
          if (unit.includes('ki')) {
            return size / 1024; // Convert KiB to MiB
          }
          // Assume bytes if no unit
          return size / (1024 * 1024);
        };

        const initializeTooltips = () => {
          // First, destroy any old tooltips to prevent memory leaks
          const existingTooltips = document.querySelectorAll('[data-bs-toggle="tooltip"]');
          existingTooltips.forEach(tooltipEl => {
            const tooltip = bootstrap.Tooltip.getInstance(tooltipEl);
            if (tooltip) {
              tooltip.dispose();
            }
          });

          [...existingTooltips].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
        };

        const formatTimestamp = (ts) => ts ? new Date(ts).toLocaleString('id-ID') : '';

        const statKeys = ['cpu', 'proc', 'mem', 'virt', 'disk', 'net']

        return {
          servers,
          initialLoadComplete,
          selectedServer,
          theme,
          statKeys,
          initializeTooltips,
          selectServer,
          getStatusText,
          getStatusClass,
          getLoadAvg,
          getMemoryInfo,
          getStorageList,
          getProgressBarClass,
          getPortStatusClass,
          formatLog,
          formatTimestamp,
          getFpmStatusClass,
          toggleTheme
        };
      }
    }).mount('#app');
  </script>

</body>

</html>